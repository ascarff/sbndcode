////////////////////////////////////////////////////////////////////////
// Class:       NumuccTree
// Module Type: analyzer
// File:        NumuccTree_module.cc
//
// Tom Brooks (tbrooks@fnal.gov)
////////////////////////////////////////////////////////////////////////

// sbndcode includes
#include "sbndcode/RecoUtils/RecoUtils.h"
#include "sbndcode/CosmicId/Utils/CosmicIdUtils.h"
#include "sbndcode/CosmicId/Algs/CosmicIdAlg.h"
#include "sbndcode/Geometry/GeometryWrappers/TPCGeoAlg.h"
#include "sbndcode/CosmicId/Algs/StoppingParticleCosmicIdAlg.h"

// LArSoft includes
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "larsim/MCCheater/BackTrackerService.h"
#include "larsim/MCCheater/ParticleInventoryService.h"
#include "lardataobj/RecoBase/MCSFitResult.h"
#include "larreco/RecoAlg/TrajectoryMCSFitter.h"
#include "larreco/RecoAlg/TrackMomentumCalculator.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "larcoreobj/SummaryData/POTSummary.h"

// Framework includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art_root_io/TFileService.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "fhiclcpp/ParameterSet.h"
#include "fhiclcpp/types/Table.h"
#include "fhiclcpp/types/Atom.h"

#include "Pandora/PdgTable.h"

// ROOT includes. Note: To look up the properties of the ROOT classes,
// use the ROOT web site; e.g.,
// <https://root.cern.ch/doc/master/annotated.html>
#include "TVector3.h"
#include "TH1.h"

// C++ includes
#include <map>
#include <vector>
#include <string>
#include <algorithm>

namespace sbnd {

  class NumuccTree : public art::EDAnalyzer {
  public:

    struct BeamTime {
      using Name = fhicl::Name;
      using Comment = fhicl::Comment;

      fhicl::Atom<double> BeamTimeMin {
        Name("BeamTimeMin"),
        Comment("")
      };

      fhicl::Atom<double> BeamTimeMax {
        Name("BeamTimeMax"),
        Comment("")
      };

    };

    // Describes configuration parameters of the module
    struct Config {
      using Name = fhicl::Name;
      using Comment = fhicl::Comment;
 
      // One Atom for each parameter
      fhicl::Atom<art::InputTag> SimModuleLabel {
        Name("SimModuleLabel"),
        Comment("tag of detector simulation data product")
      };

      fhicl::Atom<art::InputTag> GenModuleLabel {
        Name("GenModuleLabel"),
        Comment("tag of generator data product")
      };

      fhicl::Atom<art::InputTag> TpcTrackModuleLabel {
        Name("TpcTrackModuleLabel"),
        Comment("tag of TPC track producer data product")
      };

      fhicl::Atom<art::InputTag> ShowerModuleLabel {
        Name("ShowerModuleLabel"),
        Comment("tag of shower producer data product")
      };

      fhicl::Atom<art::InputTag> PidModuleLabel {
        Name("PidModuleLabel"),
        Comment("tag of PID producer data product")
      };

      fhicl::Atom<art::InputTag> CaloModuleLabel {
        Name("CaloModuleLabel"),
        Comment("tag of calorimetry producer data product")
      };

      fhicl::Atom<art::InputTag> PandoraLabel {
        Name("PandoraLabel"),
        Comment("tag of pandora data product")
      };

      fhicl::Atom<bool> Verbose {
        Name("Verbose"),
        Comment("Print information about what's going on")
      };

      fhicl::Table<CosmicIdAlg::Config> CosIdAlg {
        Name("CosIdAlg"),
      };

      fhicl::Table<trkf::TrajectoryMCSFitter::Config> fitter {
        Name("fitter"),
      };

      fhicl::Table<BeamTime> BeamTimeLimits {
        Name("BeamTimeLimits"),
        Comment("")
      };

      fhicl::Table<StoppingParticleCosmicIdAlg::Config> SPTagAlg {
        Name("SPTagAlg"),
      };

    }; // Inputs

    using Parameters = art::EDAnalyzer::Table<Config>;
 
    // Constructor: configures module
    explicit NumuccTree(Parameters const& config);
 
    // Called once, at start of the job
    virtual void beginJob() override;
 
    // Called for every sub run
    virtual void beginSubRun(const art::SubRun& subrun) override;
 
    // Called once per event
    virtual void analyze(const art::Event& event) override;

    // Called once, at end of the job
    virtual void endJob() override;

    // Reset variables in each loop
    void ResetPfpVars();
    void ResetCosPfpVars();
    void ResetNuMuVars();

    std::pair<std::pair<bool, bool>, recob::Track> TomNumucc(std::vector<recob::Track> tracks, art::FindMany<anab::ParticleID> fmpid, art::FindManyP<anab::Calorimetry> fmcalo);

    void FillNumuccTree(std::string selection, std::pair<std::pair<bool, bool>, recob::Track> selected, int trueId, std::map<int, simb::MCParticle> particles);

    double AverageDCA(const recob::Track& track);

    double HitEnergy(art::Ptr<recob::Hit> hit);
    double NeutrinoEnergy(std::map<int, double> track_energies, double shower_energy, int id);

    typedef art::Handle< std::vector<recob::PFParticle> > PFParticleHandle;
    typedef std::map< size_t, art::Ptr<recob::PFParticle> > PFParticleIdMap;

  private:

    // fcl file parameters
    art::InputTag fSimModuleLabel;      ///< name of detsim producer
    art::InputTag fGenModuleLabel;      ///< name of detsim producer
    art::InputTag fTpcTrackModuleLabel; ///< name of TPC track producer
    art::InputTag fShowerModuleLabel; ///< name of TPC track producer
    art::InputTag fPidModuleLabel; ///< name of TPC track producer
    art::InputTag fCaloModuleLabel; ///< name of TPC track producer
    art::InputTag fPandoraLabel;
    bool          fVerbose;             ///< print information about what's going on
    double        fBeamTimeMin;
    double        fBeamTimeMax;

    CosmicIdAlg cosIdAlg;
    TPCGeoAlg fTpcGeo;
    // Momentum fitters
    trkf::TrajectoryMCSFitter     fMcsFitter; 
    trkf::TrackMomentumCalculator fRangeFitter;
    StoppingParticleCosmicIdAlg  fStopTagger;
    detinfo::DetectorProperties const* fDetectorProperties;

    // Tree (One entry per reconstructed pfp)
    TTree *fPfpTree;

    //Pfp tree parameters
    bool is_cosmic;         // True origin of PFP is cosmic
    bool is_dirt;           // True origin of PFP is dirt interaction
    bool is_nu;             // True origin of PFP is nu in AV
    int nu_pdg;             // Pdg of neutrino if not cosmic
    bool is_cc;             // Is interaction CC if not cosmic
    int nu_int;             // Interaction type of neutrino if not cosmic
    double vtx_x;           // True neutrino vertex
    double vtx_y;
    double vtx_z;
    double p_x;             // True neutrino momentum
    double p_y;
    double p_z;
    double energy;          // True energy of neutrino
    bool mu_cont;           // Is true muon contained
    double mu_length;       // True contained length of muon if true numuCC
    double mu_mom;          // True momentum of muon if true numuCC
    double mu_theta;        // True theta of muon if true numuCC
    double mu_phi;          // True phi of muon if true numuCC
    double time;            // True time of interaction
    bool pandora_cosmic     // ID'd as unambiguous cosmic by pandora
    bool cosmic_id;         // ID'd as a cosmic
    int n_tracks;           // Number of reconstructed tracks in pfp
    bool longest_cont;      // Is longest track contained
    double longest_length;  // Reco contained length of longest track
    double longest_mom;     // Reco momentum of longest track
    double longest_theta;   // Reco theta of longest track
    double longest_phi;     // Reco phi of longest track
    bool selected;          // Selected as numuCC?
    bool in_fv;             // In fiducial volume of selection
    int true_pdg;           // PDG of particle prop_true as muon
    bool true_cont;         // Is selected true particle contained 
    double true_length;     // True contained length of selected particle
    double true_mom;        // True momentum of selected particle
    double true_theta;      // True theta of selected particle
    double true_phi;        // True phi of selected particle
    bool reco_cont;         // Is reconstructed track contained
    double reco_length;     // Selected muon reco length
    double reco_mom;        // Selected muon reco momentum
    double reco_theta;      // Selected muon reco theta
    double reco_phi;        // Selected muon reco phi
    double reco_nu_e;       // Reconstructed neutrino energy assuming nu_mu CC
    double reco_vtx_x;      // Reconstructed neutrino vertex X
    double reco_vtx_y;      // Reconstructed neutrino vertex Y
    double reco_vtx_z;      // Reconstructed neutrino vertex Z

    // Tree (one entry per numu CC)
    TTree *fNuMuTree;

    // NuMu tree parameters;
    double nu_vtx_x;
    double nu_vtx_y;
    double nu_vtx_z;
    double nu_p_x;
    double nu_p_y;
    double nu_p_z;
    double nu_nu_energy;
    double nu_mu_length;
    double nu_mu_mom;
    double nu_mu_theta;
    double nu_mu_phi;
    bool nu_mu_cont;

    TTree *fPotTree;
    double pot;

    void GetPFParticleIdMap(const PFParticleHandle &pfParticleHandle, PFParticleIdMap &pfParticleMap);

  }; // class NumuccTree


  // Constructor
  NumuccTree::NumuccTree(Parameters const& config)
    : EDAnalyzer(config)
    , fSimModuleLabel       (config().SimModuleLabel())
    , fGenModuleLabel       (config().GenModuleLabel())
    , fTpcTrackModuleLabel  (config().TpcTrackModuleLabel())
    , fShowerModuleLabel    (config().ShowerModuleLabel())
    , fPidModuleLabel       (config().PidModuleLabel())
    , fCaloModuleLabel      (config().CaloModuleLabel())
    , fPandoraLabel         (config().PandoraLabel())
    , fVerbose              (config().Verbose())
    , fBeamTimeMin          (config().BeamTimeLimits().BeamTimeMin())
    , fBeamTimeMax          (config().BeamTimeLimits().BeamTimeMax())
    , cosIdAlg              (config().CosIdAlg())
    , fMcsFitter            (config().fitter)
    , fStopTagger           (config().SPTagAlg())
  {

  } // NumuccTree()


  void NumuccTree::beginJob()
  {

    fDetectorProperties = lar::providerFrom<detinfo::DetectorPropertiesService>();
    
    ResetPfpVars();

    // Access tfileservice to handle creating and writing histograms
    art::ServiceHandle<art::TFileService> tfs;

    fPfpTree = tfs->make<TTree>("pfps", "pfps");

    fPfpTree->Branch("is_cosmic", &is_cosmic);
    fPfpTree->Branch("is_dirt",   &is_dirt);
    fPfpTree->Branch("is_nu",     &is_nu);
    fPfpTree->Branch("nu_pdg",    &nu_pdg);
    fPfpTree->Branch("is_cc",     &is_cc);
    fPfpTree->Branch("nu_int",    &nu_int);
    fPfpTree->Branch("vtx_x",     &vtx_x);
    fPfpTree->Branch("vtx_y",     &vtx_y);
    fPfpTree->Branch("vtx_z",     &vtx_z);
    fPfpTree->Branch("p_x",       &p_x);
    fPfpTree->Branch("p_y",       &p_y);
    fPfpTree->Branch("p_z",       &p_z);
    fPfpTree->Branch("time",      &time);
    fPfpTree->Branch("cosmic_id", &cosmic_id);
    fPfpTree->Branch("n_tracks",  &n_tracks);
    fPfpTree->Branch("nu_energy", &nu_energy);
    fPfpTree->Branch("mu_cont",   &mu_cont);
    fPfpTree->Branch("mu_length", &mu_length);
    fPfpTree->Branch("mu_mom",    &mu_mom);
    fPfpTree->Branch("mu_theta",  &mu_theta);
    fPfpTree->Branch("mu_phi",    &mu_phi);
    for(auto const& sel : selections){
      fPfpTree->Branch((sel+"_selected").c_str(),   &selected[sel]);
      fPfpTree->Branch((sel+"_in_fv").c_str(),      &in_fv[sel]);
      fPfpTree->Branch((sel+"_true_pdg").c_str(),   &true_pdg[sel]);
      fPfpTree->Branch((sel+"_true_cont").c_str(),  &true_cont[sel]);
      fPfpTree->Branch((sel+"_true_length").c_str(),&true_length[sel]);
      fPfpTree->Branch((sel+"_true_mom").c_str(),   &true_mom[sel]);
      fPfpTree->Branch((sel+"_true_theta").c_str(), &true_theta[sel]);
      fPfpTree->Branch((sel+"_true_phi").c_str(),   &true_phi[sel]);
      fPfpTree->Branch((sel+"_reco_cont").c_str(),  &reco_cont[sel]);
      fPfpTree->Branch((sel+"_reco_length").c_str(),&reco_length[sel]);
      fPfpTree->Branch((sel+"_reco_mom").c_str(),   &reco_mom[sel]);
      fPfpTree->Branch((sel+"_reco_theta").c_str(), &reco_theta[sel]);
      fPfpTree->Branch((sel+"_reco_phi").c_str(),   &reco_phi[sel]);
      fPfpTree->Branch((sel+"_reco_nu_e").c_str(),  &reco_nu_e[sel]);
      fPfpTree->Branch((sel+"_reco_vtx_x").c_str(), &reco_vtx_x[sel]);
      fPfpTree->Branch((sel+"_reco_vtx_y").c_str(), &reco_vtx_y[sel]);
      fPfpTree->Branch((sel+"_reco_vtx_z").c_str(), &reco_vtx_z[sel]);
    }

    fNuMuTree = tfs->make<TTree>("numu", "numu");

    fNuMuTree->Branch("nu_vtx_x", &nu_vtx_x);
    fNuMuTree->Branch("nu_vtx_y", &nu_vtx_y);
    fNuMuTree->Branch("nu_vtx_z", &nu_vtx_z);
    fNuMuTree->Branch("nu_p_x",   &nu_p_x);
    fNuMuTree->Branch("nu_p_y",   &nu_p_y);
    fNuMuTree->Branch("nu_p_z",   &nu_p_z);
    fNuMuTree->Branch("nu_nu_energy", &nu_nu_energy);
    fNuMuTree->Branch("nu_mu_length", &nu_mu_length);
    fNuMuTree->Branch("nu_mu_mom", &nu_mu_mom);
    fNuMuTree->Branch("nu_mu_theta", &nu_mu_theta);
    fNuMuTree->Branch("nu_mu_phi", &nu_mu_phi);
    fNuMuTree->Branch("nu_mu_cont", &nu_mu_cont);

    fPotTree = tfs->make<TTree>("pots", "pots");
    fPotTree->Branch("pot",  &pot);

    // Initial output
    if(fVerbose) std::cout<<"----------------- Cosmic ID Ana Module -------------------"<<std::endl;

  }// NumuccTree::beginJob()

  // Called for every sub run
  void NumuccTree::beginSubRun(const art::SubRun& subrun){

    art::Handle< sumdata::POTSummary > potHandle;
    subrun.getByLabel(fGenModuleLabel, potHandle);
    const sumdata::POTSummary& potSum = (*potHandle);
    pot = potSum.totpot;

    fPotTree->Fill();

    return;
  }

  void NumuccTree::analyze(const art::Event& event)
  {

    // Fetch basic event info
    if(fVerbose){
      std::cout<<"============================================"<<std::endl
               <<"Run = "<<event.run()<<", SubRun = "<<event.subRun()<<", Event = "<<event.id().event()<<std::endl
               <<"============================================"<<std::endl;
    }

    //----------------------------------------------------------------------------------------------------------
    //                                          GETTING PRODUCTS
    //----------------------------------------------------------------------------------------------------------

    // Get PFParticles from pandora
    PFParticleHandle pfParticleHandle;
    event.getByLabel(fPandoraLabel, pfParticleHandle);
    if( !pfParticleHandle.isValid() ){
      if(fVerbose) std::cout<<"Failed to find the PFParticles."<<std::endl;
      return;
    }
    PFParticleIdMap pfParticleMap;
    this->GetPFParticleIdMap(pfParticleHandle, pfParticleMap);
    // Get PFParticle to track associations
    art::FindManyP< recob::Track > pfPartToTrackAssoc(pfParticleHandle, event, fTpcTrackModuleLabel);
    
    // Get track to hit and colorimetry associations
    auto tpcTrackHandle = event.getValidHandle<std::vector<recob::Track>>(fTpcTrackModuleLabel);
    art::FindManyP<recob::Hit> findManyHits(tpcTrackHandle, event, fTpcTrackModuleLabel);
    art::FindMany<anab::ParticleID> findManyPid(tpcTrackHandle, event, fPidModuleLabel);
    art::FindManyP<anab::Calorimetry> findManyCalo(tpcTrackHandle, event, fCaloModuleLabel);

    // Get shower handle
    auto showerHandle = event.getValidHandle<std::vector<recob::Shower>>(fShowerModuleLabel);
    // Get PFParticle to shower associations
    art::FindManyP< recob::Shower > pfPartToShowerAssoc(pfParticleHandle, event, fShowerModuleLabel);
    // Get shower to hit associations
    art::FindManyP<recob::Hit> findManyHitsShower(showerHandle, event, fShowerModuleLabel);

    
    //----------------------------------------------------------------------------------------------------------
    //                                     NUMUCC SELECTION
    //----------------------------------------------------------------------------------------------------------

    //Loop over the pfparticle map
    std::vector<double> used_nus;
    for (PFParticleIdMap::const_iterator it = pfParticleMap.begin(); it != pfParticleMap.end(); ++it){

      const art::Ptr<recob::PFParticle> pParticle(it->second);
      // Only look for primary particles
      if (!pParticle->IsPrimary()) continue;
      // Check if this particle is identified as the neutrino
      const int pdg(pParticle->PdgCode());
      const bool isNeutrino(std::abs(pdg) == pandora::NU_E || 
                            std::abs(pdg) == pandora::NU_MU || 
                            std::abs(pdg) == pandora::NU_TAU);
      //Find neutrino pfparticle
      if(!isNeutrino) continue;

      ResetPfpVars();

      std::vector<recob::Track> nuTracks;
      std::vector<art::Ptr<recob::Hit>> all_hits;
      std::map<int, double> track_energies;
      double shower_energy = 0;

      const std::vector< art::Ptr<recob::Track> > associatedTracks(pfPartToTrackAssoc.at(pParticle.key()));
      if(associatedTracks.size() == 1){ 
        recob::Track tpcTrack = *associatedTracks.front();
        nuTracks.push_back(tpcTrack);

        // Truth match the pfps using all hits associated to all tracks associated to neutrino pfp
        std::vector<art::Ptr<recob::Hit>> hits = findManyHits.at(tpcTrack.ID());
        all_hits.insert(all_hits.end(), hits.begin(), hits.end());
      }

      // Loop over daughters of pfparticle and do some truth matching
      // Assign labels based on the particle constributing the most hits
      for (const size_t daughterId : pParticle->Daughters()){

        // Get tracks associated with daughter
        art::Ptr<recob::PFParticle> pDaughter = pfParticleMap.at(daughterId);
        const std::vector< art::Ptr<recob::Track> > associatedTracks(pfPartToTrackAssoc.at(pDaughter.key()));
        const std::vector< art::Ptr<recob::Shower> > associatedShowers(pfPartToShowerAssoc.at(pDaughter.key()));

        // Add up track and shower energy
        for(size_t i = 0; i < associatedTracks.size(); i++){
          std::vector<art::Ptr<anab::Calorimetry>> calos = findManyCalo.at(associatedTracks[i]->ID());
          if(calos.size()==0) continue;
          size_t nhits = 0;
          size_t best_plane = 0;
          for( size_t j = calos.size(); j > 0; j--){
            if(calos[j-1]->dEdx().size() > nhits*1.5){
              nhits = calos[j-1]->dEdx().size();
              best_plane = j-1;
            }
          }
          track_energies[associatedTracks[i]->ID()] = calos[best_plane]->KineticEnergy()/1e3;
        }
        for(size_t i = 0; i < associatedShowers.size(); i++){
          std::vector<art::Ptr<recob::Hit>> hits = findManyHitsShower.at(associatedShowers[i]->ID());
          for(size_t j = 0; j < hits.size(); j++){
            // Assume collection plane is best for showers
            if(hits[j]->WireID().Plane == 2){ 
              shower_energy += HitEnergy(hits[j]);
            }
          }
        }

        if(associatedTracks.size() != 1) continue; //TODO check how often this occurs

        // Get the first associated track
        recob::Track tpcTrack = *associatedTracks.front();
        nuTracks.push_back(tpcTrack);

        // Truth match the pfps using all hits associated to all tracks associated to neutrino pfp
        std::vector<art::Ptr<recob::Hit>> hits = findManyHits.at(tpcTrack.ID());
        all_hits.insert(all_hits.end(), hits.begin(), hits.end());

      }

      int trueId = RecoUtils::TrueParticleIDFromTotalRecoHits(all_hits, false);

      // Skip if no corresponding true particle
      if(particles.find(trueId) == particles.end()) continue;

      // Get the origin of the particle
      art::Ptr<simb::MCTruth> truth = pi_serv->TrackIdToMCTruth_P(trueId);
      if(truth->Origin() == simb::kBeamNeutrino){
        // Save neutrino interaction info
        nu_pdg = truth->GetNeutrino().Nu().PdgCode();
        if(truth->GetNeutrino().CCNC() == simb::kCC) is_cc = true;
        nu_int = truth->GetNeutrino().InteractionType();
        nu_energy = truth->GetNeutrino().Nu().E();

        // Avoid double counting neutrinos
        // FIXME if this ever happens need better way of deciding which pfp to keep
        if(std::find(used_nus.begin(), used_nus.end(), nu_energy) != used_nus.end()) continue;
        used_nus.push_back(nu_energy);

        // If neutrino vertex is not inside the TPC then call it a dirt particle
        geo::Point_t vtx {truth->GetNeutrino().Nu().Vx(), 
                          truth->GetNeutrino().Nu().Vy(), 
                          truth->GetNeutrino().Nu().Vz()};
        vtx_x = vtx.X();
        vtx_y = vtx.Y();
        vtx_z = vtx.Z();
        p_x = truth->GetNeutrino().Nu().Px();
        p_y = truth->GetNeutrino().Nu().Py();
        p_z = truth->GetNeutrino().Nu().Pz();
        if(!fTpcGeo.InFiducial(vtx, 0, 0)) is_dirt = true;
        else is_nu = true;

        // If it's a numuCC then save the muon kinematics
        // Get the primary muon
        std::vector<const simb::MCParticle*> parts = pi_serv->MCTruthToParticles_Ps(truth);
        for(auto const& part : parts){
          if(std::abs(part->PdgCode()) != 13) continue;
          if(part->Mother() != 0) continue;
          if(part->StatusCode() != 1) continue;
          TVector3 start(part->Vx(), part->Vy(), part->Vz());
          TVector3 end(part->EndX(), part->EndY(), part->EndZ());
          mu_length = fTpcGeo.TpcLength(*part);
          mu_mom = part->P();
          mu_theta = (end-start).Theta();
          mu_phi = (end-start).Phi();
          mu_cont = fTpcGeo.IsContained(*part);
        }

      }
      else if(truth->Origin() == simb::kCosmicRay) is_cosmic = true;

      n_tracks = nuTracks.size();

      // Skip any PFPs without any tracks in them
      if(n_tracks == 0) continue;

      // Does pfp look like a cosmic?
      cosmic_id = cosIdAlg.CosmicId(*pParticle, pfParticleMap, event);

      // -------------------------------------- APPLY SELECTIONS ---------------------------------------
      std::pair<std::pair<bool, bool>, recob::Track> sel_track = TomNumucc(nuTracks, findManyPid, findManyCalo);
      std::vector<art::Ptr<recob::Hit>> hits = findManyHits.at(sel_track.second.ID());
      int trueId = RecoUtils::TrueParticleIDFromTotalRecoHits(hits, false);
      FillNumuccTree(sel, sel_track, trueId, particles);
      reco_nu_e[sel] = NeutrinoEnergy(track_energies, shower_energy, sel_track.second.ID());

      fPfpTree->Fill();

    }  

  } // NumuccTree::analyze()


  void NumuccTree::endJob(){

  } // NumuccTree::endJob()

  void NumuccTree::GetPFParticleIdMap(const PFParticleHandle &pfParticleHandle, PFParticleIdMap &pfParticleMap){
      for (unsigned int i = 0; i < pfParticleHandle->size(); ++i){
          const art::Ptr<recob::PFParticle> pParticle(pfParticleHandle, i);
          if (!pfParticleMap.insert(PFParticleIdMap::value_type(pParticle->Self(), pParticle)).second){
              std::cout << "  Unable to get PFParticle ID map, the input PFParticle collection has repeat IDs!" <<"\n";
          }
      }
  }

  // Reset the tree variables
  void NumuccTree::ResetPfpVars(){
    is_cosmic = false;
    is_dirt = false;
    is_nu = false;
    nu_pdg = -99999;
    is_cc = false;
    nu_int = -99999;
    vtx_x = -99999;
    vtx_y = -99999;
    vtx_z = -99999;
    p_x = -99999;
    p_y = -99999;
    p_z = -99999;
    time = -99999;
    cosmic_id = false;
    n_tracks = 0;
    nu_energy = -99999;
    mu_cont = false;
    mu_length = -99999;
    mu_mom = -99999;
    mu_theta = -99999;
    mu_phi = -99999;
    for(auto const& sel : selections){
      selected[sel] = false;
      true_pdg[sel] = -99999;
      true_cont[sel] = false;
      true_length[sel] = -99999;
      true_mom[sel] = -99999;
      true_theta[sel] = -99999;
      true_phi[sel] = -99999;
      reco_cont[sel] = false;
      reco_length[sel] = -99999;
      reco_mom[sel] = -99999;
      reco_theta[sel] = -99999;
      reco_phi[sel] = -99999;
      reco_nu_e[sel] = -99999;
      reco_vtx_x[sel] = -99999;
      reco_vtx_y[sel] = -99999;
      reco_vtx_z[sel] = -99999;
    }
  }

  void NumuccTree::ResetNuMuVars(){
    nu_vtx_x = -99999;
    nu_vtx_y = -99999;
    nu_vtx_z = -99999;
    nu_p_x = -99999;
    nu_p_y = -99999;
    nu_p_z = -99999;
    nu_nu_energy = -99999;
    nu_mu_mom = -99999;
    nu_mu_theta = -99999;
    nu_mu_phi = -99999;
    nu_mu_cont = false;
  }

  // Apply my selection
  std::pair<std::pair<bool, bool>, recob::Track> NumuccTree::TomNumucc(std::vector<recob::Track> tracks, art::FindMany<anab::ParticleID> fmpid, art::FindManyP<anab::Calorimetry> fmcalo){

    bool is_selected = false;
    bool has_candidate = false;
    recob::Track candidate = tracks[0];

    // Loop over tracks and count how many escape
    // For contained tracks apply PID cuts to only retain muon-like tracks
    int n_escape = 0;
    double longest_escape = 0;
    std::vector<recob::Track> long_tracks;
    for(size_t i = 0; i < tracks.size(); i++){
      // Find longest escaping track and don't apply track cuts if escaping
      if(!fTpcGeo.InFiducial(tracks[i].End(), 1.5)){
        n_escape++;
        double length = tracks[i].Length();
        if(length > longest_escape){ 
          longest_escape = length;
        }
        long_tracks.push_back(tracks[i]);
        continue;
      }

      // Select if longer than 150 cm
      if(tracks[i].Length() > 100.){
        long_tracks.push_back(tracks[i]);
        continue;
      }

      // Loop over planes (Y->V->U) and choose the next plane's calorimetry if there are 1.5x more points (collection plane more reliable)
      std::vector<art::Ptr<anab::Calorimetry>> calos = fmcalo.at(tracks[i].ID());
      if(calos.size()==0) continue;
      size_t nhits = 0;
      art::Ptr<anab::Calorimetry> calo = calos[0];
      size_t best_plane = 0;
      for( size_t i = calos.size(); i > 0; i--){
        if(calos[i-1]->dEdx().size() > nhits*1.5){
          nhits = calos[i-1]->dEdx().size();
          calo = calos[i-1];
          best_plane = i-1;
        }
      }

      // Get rid of any protons using chi2
      std::vector<const anab::ParticleID*> pids = fmpid.at(tracks[i].ID());
      bool is_proton = false;
      for(size_t i = 0; i < pids.size(); i++){
        // Only use the collection plane
        if(pids[i]->PlaneID().Plane != best_plane) continue;
        // If minimum chi2 is proton then ignore
        if(pids[i]->Chi2Proton() < pids[i]->Chi2Muon() && pids[i]->Chi2Proton() < pids[i]->Chi2Pion()){ 
          is_proton = true;
          continue;
        }
      }
      if(is_proton) continue;

      // Get rid of tracks which don't scatter like muons
      std::vector<float> angles = fMcsFitter.fitMcs(tracks[i], 13).scatterAngles();
      double ave_angle = std::accumulate(angles.begin(), angles.end(), 0)/angles.size();
      if(AverageDCA(tracks[i]) < 0.2 || ave_angle < 30) continue;

      // Get rid of any contained particles which don't stop (most muons do)
      double stop_chi2 = fStopTagger.StoppingChiSq(tracks[i].End(), calos);
      if(stop_chi2 < 1.2) continue;

      // Reject any tracks shorter than 25 cm
      if(tracks[i].Length() < 25) continue;

      // Check momentum reconstruction quality
      double range_mom = fRangeFitter.GetTrackMomentum(tracks[i].Length(), 13);
      double mcs_mom = fMcsFitter.fitMcs(tracks[i], 13).bestMomentum();
      double mom_diff = (mcs_mom - range_mom)/range_mom;
      double mom_diff_limit = 0.5 + std::exp(-(tracks[i].Length()-15.)/10.);
      if(mom_diff > mom_diff_limit) continue;

      long_tracks.push_back(tracks[i]);
    }

    std::sort(long_tracks.begin(), long_tracks.end(), [](auto& left, auto& right){
              return left.Length() > right.Length();});

    // Case 1: 1 escaping track
    if(n_escape == 1 && long_tracks.size() > 0){
      // If escaping track is longest and length > 50 cm then ID as muon
      if(longest_escape == long_tracks[0].Length() && longest_escape > 50){
        has_candidate = true;
        candidate = long_tracks[0];
      }
    }

    // Case 2: All tracks contained
    else if(n_escape == 0 && long_tracks.size() > 0){
      // Select the longest track
      has_candidate = true;
      candidate = long_tracks[0];
    }

    // Check vertex (start of muon candidate) in FV
    // Fiducial definition 50 cm from back, 10 cm from left, right and bottom, 15 cm from front, 20 cm from top 
    // 5 cm either side of CPA, 2.5 cm either side of APA gap
    bool in_fiducial = fTpcGeo.InFiducial(candidate.Start(), 10., 10., 15., 10., 20., 50., 5., 2.5);
    if(has_candidate) is_selected = true;

    return std::make_pair(std::make_pair(is_selected, in_fiducial), candidate);

  }

  //------------------------------------------------------------------------------------------------------------------------------------------
    
  void NumuccTree::FillNumuccTree(std::string selection, std::pair<std::pair<bool, bool>, recob::Track> sel_track, int trueId, std::map<int, simb::MCParticle> particles){

    selected[selection] = sel_track.first.first;
    in_fv[selection] = sel_track.first.second;

    // Calculate kinematic variables for prop_sel_track prop_track
    reco_cont[selection] = fTpcGeo.InFiducial(sel_track.second.End(), 1.5);
    reco_length[selection] = sel_track.second.Length();
    reco_mom[selection] = 0.;
    if(reco_cont[selection]){
      reco_mom[selection] = fRangeFitter.GetTrackMomentum(reco_length[selection], 13);
    }
    else{
      recob::MCSFitResult mcsResult = fMcsFitter.fitMcs(sel_track.second);
      reco_mom[selection] = mcsResult.bestMomentum();
    }
    reco_theta[selection] = sel_track.second.Theta();
    reco_phi[selection] = sel_track.second.Phi();
    reco_vtx_x[selection] = sel_track.second.Start().X();
    reco_vtx_y[selection] = sel_track.second.Start().Y();
    reco_vtx_z[selection] = sel_track.second.Start().Z();

    // Get the true kinematic variables
    if(particles.find(trueId) != particles.end()){
      TVector3 start(particles[trueId].Vx(), particles[trueId].Vy(), particles[trueId].Vz());
      TVector3 end(particles[trueId].EndX(), particles[trueId].EndY(), particles[trueId].EndZ());
      true_length[selection] = fTpcGeo.TpcLength(particles[trueId]);
      true_mom[selection] = particles[trueId].P();
      true_theta[selection] = (end-start).Theta();
      true_phi[selection] = (end-start).Phi();
      true_cont[selection] = fTpcGeo.IsContained(particles[trueId]);
      true_pdg[selection] = particles[trueId].PdgCode();
    }

  }

 double NumuccTree::AverageDCA(const recob::Track& track){

    TVector3 start = track.Vertex<TVector3>();
    TVector3 end = track.End<TVector3>();
    double denominator = (end - start).Mag();
    size_t npts = track.NumberTrajectoryPoints();
    double aveDCA = 0;
    int usedPts = 0;
    for(size_t i = 0; i < npts; i++){
      TVector3 point = track.LocationAtPoint<TVector3>(i);
      if(!track.HasValidPoint(i)) continue;
      aveDCA += (point - start).Cross(point - end).Mag()/denominator;
      usedPts++;
    }   
    return aveDCA/usedPts;
  } 

  double NumuccTree::HitEnergy(art::Ptr<recob::Hit> hit){

    double ADCtoEl = 0.02354; //FIXME from calorimetry_sbnd.fcl
    double time = hit->PeakTime();
    double timetick = fDetectorProperties->SamplingRate()*1e-3;
    double presamplings = fDetectorProperties->TriggerOffset();
    time -= presamplings;
    time = time*timetick;
    double tau = fDetectorProperties->ElectronLifetime();
    double correction = std::exp(time/tau);
    return fDetectorProperties->ModBoxCorrection((hit->Integral()/ADCtoEl)*correction)/1e3; //[GeV]
    
  }

  double NumuccTree::NeutrinoEnergy(std::map<int, double> track_energies, double shower_energy, int id){
    double nu_e = 0;
    if(shower_energy>0 && shower_energy<5) nu_e = shower_energy;
    for(auto const& kv : track_energies){
      if(kv.first != id && kv.second>0 && kv.second<5) nu_e += kv.second;
    }
    return nu_e;
  }

  DEFINE_ART_MODULE(NumuccTree)
} // namespace sbnd

