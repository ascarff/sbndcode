////////////////////////////////////////////////////////////////////////
// Class:       opHitFinderSBND
// Module Type: producer
// File:        opHitFinderSBND_module.cc
//
// This module produces an OpHit object for light analysis
// Created by L. Paulucci and F. Marinho
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Utilities/Exception.h"
#include "canvas/Utilities/InputTag.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art_root_io/TFileService.h"

#include "larcore/Geometry/Geometry.h"
#include "lardataobj/RawData/OpDetWaveform.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
//#include "larana/OpticalDetector/OpHitFinder/OpHitAlg.h"
//#include "lardataobj/Simulation/BeamGateInfo.h"

#include "lardata/DetectorInfoServices/DetectorClocksServiceStandard.h"
#include "lardataobj/Simulation/sim.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/SimPhotons.h"
#include "sbndcode/Utilities/SignalShapingServiceSBND.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
//#include "larsim/MCCheater/PhotonBackTracker.h"

#include <memory>
#include <algorithm>
#include <vector>
#include "TMath.h"
#include "TH1D.h"
#include "TRandom3.h"
#include "TF1.h"

#include "sbndPDMapAlg.h" 

namespace opdet{

  class opHitFinderSBND;

  class opHitFinderSBND : public art::EDProducer {
  public:
    explicit opHitFinderSBND(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    opHitFinderSBND(opHitFinderSBND const &) = delete;
    opHitFinderSBND(opHitFinderSBND &&) = delete;
    opHitFinderSBND & operator = (opHitFinderSBND const &) = delete;
    opHitFinderSBND & operator = (opHitFinderSBND &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;
    opdet::sbndPDMapAlg map; //map for photon detector types

  private:

    // Declare member data here.
    std::string fInputModuleName;
    //  art::ServiceHandle<cheat::PhotonBackTracker> pbt;
    double fSampling; //in MHz
    double fBaselineSample; //in ticks
    double fUseDenoising; 
    double fPulsePolarityPMT; 
    double fPulsePolarityArapuca; 
    double fSaturation; //in number of p.e.
    double fArea1pePMT; //area of 1 pe in ADC*ns for PMTs
    double fArea1peSiPM; //area of 1 pe in ADC*ns for Arapucas
    int fThresholdPMT; //in ADC
    int fThresholdArapuca; //in ADC
    int fEvNumber;
    int fChNumber;
    std::vector<double> fwaveform;
    std::vector<double> outwvform;
    //int fSize;
    //int fTimePMT;         //Start time of PMT signal
    //int fTimeMax;         //Time of maximum (minimum) PMT signal
    void subtractBaseline(std::vector<double>& waveform, std::string pdtype, double& rms);
    bool findPeak(std::vector<double>& waveform, size_t& time, double& Area, double rms, double& amplitude, std::string type);
    void denoise(std::vector<double>& waveform, std::vector<double>& outwaveform);
    bool TV1D_denoise(std::vector<double>& waveform, std::vector<double>& outwaveform, const double lambda);
    //std::stringstream histname;
  };

  opHitFinderSBND::opHitFinderSBND(fhicl::ParameterSet const & p)
   : EDProducer{p}
  // Initialize member data here.
  {
    fInputModuleName = p.get< std::string >("InputModule" );
    fBaselineSample  = p.get< int    >("BaselineSample"); //in ticks
    fSaturation      = p.get< double >("Saturation"   ); //in number of p.e.
    fArea1pePMT      = p.get< double >("Area1pePMT"   ); //in ADC*ns for PMTs
    fArea1peSiPM     = p.get< double >("Area1peSiPM"  ); //in ADC*ns for SiPMs
    fThresholdPMT    = p.get< double >("ThresholdPMT" ); //in ADC
    fThresholdArapuca = p.get< double >("ThresholdArapuca"); //in ADC
    fUseDenoising     = p.get< int   >("UseDenoising"); 
    fPulsePolarityPMT = p.get< int   >("PulsePolarityPMT");
    fPulsePolarityArapuca = p.get< int   >("PulsePolarityArapuca");

    auto const *timeService = lar::providerFrom< detinfo::DetectorClocksService >();
    fSampling = (timeService->OpticalClock().Frequency()); // MHz
//    fSampling = (timeService->OpticalClock().Frequency())/1000.0; // GHz

    // Call appropriate produces<>() functions here.
    produces<std::vector<recob::OpHit>>();
  }

  void opHitFinderSBND::produce(art::Event & e)
  {
    // Implementation of required member function here.
    fEvNumber = e.id().event();
    std::cout << "Event #" << fEvNumber << std::endl;

    std::unique_ptr< std::vector< recob::OpHit > > pulseVecPtr(std::make_unique< std::vector< recob::OpHit > > ());
    fwaveform.reserve(30000); // TODO: no hardcoded value
    outwvform.reserve(30000); // TODO: no hardcoded value

    art::ServiceHandle<art::TFileService> tfs;
    art::Handle< std::vector< raw::OpDetWaveform > > wvfHandle;
    std::vector<art::Ptr<raw::OpDetWaveform>> wvfList;
    if(e.getByLabel(fInputModuleName, wvfHandle))
      art::fill_ptr_vector(wvfList, wvfHandle);

    if(!wvfHandle.isValid()){
      std::cout <<Form("Did not find any waveform") << std::endl;
    }

    size_t timebin=0;
    double FWHM=1, Area=0, phelec, fasttotal=3./4., rms=0, amplitude=0, time=0;
    unsigned short frame=1;
    //int histogram_number = 0;
    for(auto const& wvf_P : wvfList){
      auto const& wvf = *wvf_P;
      if (wvf.size() == 0 ) {
        std::cout << "Empty waveform, continue." << std::endl;
        continue;
      }

      fChNumber = wvf.ChannelNumber();
      fwaveform.resize(wvf.size());
      for(unsigned int i=0;i<wvf.size();i++){
        fwaveform[i]=wvf[i];
      }

      subtractBaseline(fwaveform, map.pdName(fChNumber), rms);

      if(fUseDenoising == 1){
        if((map.pdName(fChNumber)=="pmt") || (map.pdName(fChNumber)== "barepmt")){
        }
        else if((map.pdName(fChNumber)=="arapucaT1") || (map.pdName(fChNumber)== "arapucaT2")){
          denoise(fwaveform, outwvform);
        }
        else if((map.pdName(fChNumber)=="xarapucaT1") || (map.pdName(fChNumber)== "xarapucaT2")){
          denoise(fwaveform, outwvform);
        }
        else {
          std::cout << "Unexpected OpChannel: " << map.pdName(fChNumber)
                    << ", continue." << std::endl;
          std::terminate();
        }
      }

      int i=1;
      while(findPeak(fwaveform, timebin, Area, rms, amplitude, map.pdName(fChNumber))){
        time = wvf.TimeStamp() + (double)timebin/fSampling;

        if(map.pdName(fChNumber)=="pmt" || map.pdName(fChNumber) == "barepmt"){
          phelec=Area/fArea1pePMT;
        }
        else if((map.pdName(fChNumber)=="arapucaT1") || (map.pdName(fChNumber)== "arapucaT2")){
          phelec=Area/fArea1peSiPM;
        }
        else if((map.pdName(fChNumber)=="xarapucaT1") || (map.pdName(fChNumber)== "xarapucaT2")){
          phelec=Area/fArea1peSiPM;
        }
        else {
          std::cout << "Unexpected OpChannel: " << map.pdName(fChNumber)
                    << ", continue." << std::endl;
          continue;
        }

        i++;
        //including hit info: OpChannel, PeakTime, PeakTimeAbs, Frame, Width, Area, PeakHeight, PE, FastToTotal
        recob::OpHit opHit(fChNumber, time, time, frame, FWHM, Area, amplitude, phelec, fasttotal);
        pulseVecPtr->emplace_back(opHit);
      } // while findPeak()
      //     histogram_number += 1;
      // fwaveform.clear();
    } // for(auto const& wvf : (*wvfHandle)){

    e.put(std::move(pulseVecPtr));
    std::vector<double>().swap(fwaveform); // clear and release the memory of fwaveform
    std::vector<double>().swap(outwvform); // clear and release the memory of outwvform
  } // void opHitFinderSBND::produce(art::Event & e)

  DEFINE_ART_MODULE(opHitFinderSBND)

  void opHitFinderSBND::subtractBaseline(std::vector<double>& waveform, std::string pdtype, double& rms){
    double baseline = 0.0;
    rms = 0.0;
    int cnt = 0;
    for(int i=0; i<fBaselineSample; i++){
      baseline += waveform[i];
      rms += pow(waveform[i],2.0);
      cnt++;
    }

    baseline = baseline/cnt;
    rms = sqrt(rms/cnt-baseline*baseline);
    rms = rms/sqrt(cnt-1);

    if(pdtype=="pmt" || pdtype == "barepmt"){
      for(unsigned int i=0; i<waveform.size(); i++) waveform[i]=fPulsePolarityPMT*(waveform[i]-baseline);
    }
    else if((map.pdName(fChNumber)=="arapucaT1") || (map.pdName(fChNumber)== "arapucaT2")){
      for(unsigned int i=0; i<waveform.size(); i++) waveform[i]=fPulsePolarityArapuca*(waveform[i]-baseline);
    }
    else if((map.pdName(fChNumber)=="xarapucaT1") || (map.pdName(fChNumber)== "xarapucaT2")){
      for(unsigned int i=0; i<waveform.size(); i++) waveform[i]=fPulsePolarityArapuca*(waveform[i]-baseline);
    }
    else {
      std::cout << "Unexpected OpChannel: " << map.pdName(fChNumber) << std::endl;
      return;
    }
  }

  bool opHitFinderSBND::findPeak(std::vector<double>& waveform, size_t& time, double& Area, double rms, double& amplitude, std::string type){

    //Gets info from highest peak and suppress it 
    double aux = *max_element(waveform.begin(), waveform.end());
    double max;
    size_t time_end, bin, binmax = distance(waveform.begin(),max_element(waveform.begin(), waveform.end()));
    int threshold;
    Area=0;

    if(type=="pmt" || type == "barepmt"){
      threshold=fThresholdPMT;
    }
    else if((map.pdName(fChNumber)=="arapucaT1") || (map.pdName(fChNumber)== "arapucaT2")){
      threshold=fThresholdArapuca;
    }
    else if((map.pdName(fChNumber)=="xarapucaT1") || (map.pdName(fChNumber)== "xarapucaT2")){
      threshold=fThresholdArapuca;
    }
    else {
      std::cout << "Unexpected OpChannel: " << map.pdName(fChNumber) << std::endl;
      return false;
    }

    bin = binmax;
    amplitude = aux;
    max = aux;

    if(aux<threshold) return false;

    while(aux >= threshold){
        bin++;	
        if(bin > waveform.size()-1) break;
        aux = waveform[bin];
    }
    time_end = bin-1; //looking for the length of the peak

    aux = max;
    bin = binmax;
    while(aux >= threshold){
        bin--;
        if((int)bin < 0) break;
        aux = waveform[bin];
    }
    time = bin+1; //for rise time
    for(unsigned int j=time; j<=time_end; j++) Area += waveform[j];
    Area = Area/fSampling;

    bin = time;
    aux = waveform[time];  

    while(aux >= threshold){
        waveform[bin] = 0.0;
        bin++;
        if(bin > waveform.size()-1) break;
        aux = waveform[bin];
    }
    //std::cout << time << " " << time_end << " " << (time_end - time);
    time=binmax; //returning the peak time
    return true;		
  }

  void opHitFinderSBND::denoise(std::vector<double>& waveform, std::vector<double>& outwaveform){

    int wavelength = waveform.size();
    outwaveform = waveform;  // copy
    double lambda = 10.0;
    const uint retries = 5; uint try_ = 0;
    if (wavelength > 0){
      while (try_ <= retries) {
        if (TV1D_denoise(waveform, outwaveform, lambda)) break;
        try_++;
        mf::LogInfo("opHitFinder") << try_ << "/" << retries
                                   << " Coming out of TV1D_denoise() unsuccessfully, "
                                   << "using lambda: " << lambda;
        lambda += 0.1*lambda;
        if (try_ == retries) mf::LogWarning("opHitFinder") <<  "Couldn't denoise!";
      }
    }

    for(int i=0; i<wavelength; i++){
      if(outwaveform[i]) waveform[i]=outwaveform[i];
    }
  } // void opHitFinderSBND::denoise()

  // TODO: this function is not robust, check if the expected input is given and put exceptions
  bool opHitFinderSBND::TV1D_denoise(std::vector<double>& waveform, std::vector<double>& outwaveform, const double lambda)
  {
    int width = waveform.size();
    int k = 0, k0 = 0; // k: current sample location, k0: beginning of current segment
    double umin = lambda, umax = -lambda; // u is the dual variable
    double vmin = waveform[0] - lambda, vmax = waveform[0] + lambda; // bounds for the segment's value
    int kplus = 0, kminus = 0; // last positions where umax=-lambda, umin=lambda, respectively
    const double twolambda = 2.0 * lambda; // auxiliary variable
    const double minlambda = -lambda; // auxiliary variable
    for (;;) { // simple loop, the exit test is inside
      while (k == width - 1) { // we use the right boundary condition
        if (umin < 0.0) { // vmin is too high -> negative jump necessary
          do outwaveform[k0++] = vmin; while (k0 <= kminus);
          umax = (vmin = waveform[kminus = k = k0]) + (umin = lambda) - vmax;
        }
        else if (umax > 0.0) { // vmax is too low -> positive jump necessary
          do outwaveform[k0++] = vmax; while (k0 <= kplus);
          umin = (vmax = waveform[kplus = k = k0]) + (umax = minlambda) - vmin;
        }
        else {
          vmin += umin / (k - k0 + 1);
          do outwaveform[k0++] = vmin; while(k0 <= k);
          return true;
        }
      } // while (k == width - 1)
      if ((umin += waveform[k + 1] - vmin) < minlambda) { // negative jump necessary
        if (k0 > width) return false;
        do outwaveform[k0++] = vmin; while (k0 <= kminus);
        vmax = (vmin = waveform[kplus = kminus = k = k0]) + twolambda;
        umin = lambda; umax = minlambda;
      }
      else if ((umax += waveform[k + 1] - vmax) > lambda) { // positive jump necessary
        if (k0 > width) return false;
        do outwaveform[k0++] = vmax; while (k0 <= kplus);
        vmin = (vmax = waveform[kplus = kminus = k = k0]) - twolambda;
        umin = lambda; umax = minlambda;
      }
      else {   //no jump necessary, we continue
        k++;
        if (k > width) return false;
        if (umin >= lambda) { // update of vmin
          vmin += (umin - lambda) / ((kminus = k) - k0 + 1);
          umin = lambda;
        }
        if (umax <= minlambda) { // update of vmax
          vmax += (umax + lambda) / ((kplus = k) - k0 + 1);
          umax = minlambda;
        }
      }
    } // for (;;)
  } // void opHitFinderSBND::TV1D_denoise()

} // namespace opdet
